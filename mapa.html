<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SIM ‚Äì Sistema Integrado de Mobilidade de Contagem</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />

  <style>
    :root{
      --accent:#005029;
      --accent-2:#e0ff41;
      --accent-3:#058933;
      --muted:#6b7280;
      --bg:#f4f7fb;
    }
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Segoe UI,Arial,Helvetica,sans-serif;margin:0;background:var(--bg);color:#0f172a;padding-top:120px}

    /* Header */
    header{
      position:fixed; top:0; left:0; right:0; height:115px; display:flex; align-items:center; justify-content:space-between;
      background:#fff; z-index:1200; box-shadow:0 6px 18px rgba(2,6,23,0.06);
      padding: 0 20px;
    }
    .header-content {
      display:flex; align-items:center; gap:20px; position:absolute; left:50%; transform:translateX(-50%);
    }
    header a{text-decoration:none; display:flex; flex-direction:column; align-items:center; cursor:default;}
    header img{height:70px; width:auto; max-height:70px;}
    #top-right-controls { display:flex; align-items:center; gap:8px; position:absolute; right:20px; top:15px; z-index:1201; }
    #clock{ font-family:Consolas,monospace; font-size:1.2em; font-weight:600; color:var(--accent); padding:6px 10px; border-radius:8px; background:#f4f7fb; border:1px solid #eef3fb; }
    #sim-logout-btn{ display:none; background:#ff5c5c; color:#fff; border:none; padding:6px 10px; border-radius:10px; cursor:pointer; font-weight:600; margin-left:8px; }

    .container{display:grid;grid-template-columns:360px 1fr;gap:14px;padding:16px;max-width:1600px;margin:0 auto;}
    .panel{background:#fff;border-radius:12px;padding:14px;box-shadow:0 1px 6px rgba(2,6,23,0.04)}
    input,select,button{padding:10px;border-radius:10px;border:1px solid #e6eef6;font-size:14px}
    button{cursor:pointer;background:var(--accent);color:white;border:none;transition:all 0.15s ease}
    button.ghost{cursor:pointer;background:transparent;color:var(--accent-3);border:1px solid rgba(5,137,51,0.12); transition:all 0.15s ease}
    
    .panel.controls{
      overflow-y:auto; 
      max-height:calc(100vh - 152px); 
    }
    
    .tab-menu-wrapper{display:flex;justify-content:center;gap:8px;margin-bottom:12px}
    .tab-btn{transition:background .2s;color:#6b7280;padding:8px 10px;border-radius:8px;border:1px solid #e6eef6;background:transparent}
    .tab-btn.active{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* Nearby list */
    #nearby-lines-list .list-group-item{ cursor:pointer;padding:8px 10px;border:1px solid #eef3fb;border-radius:8px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center;background:#f8fafc }
    .line-code{font-weight:700;margin-right:5px}

    /* GEOP specific */
    .geop-location-marker { 
      border: 3px solid var(--accent-3); 
      border-radius: 50%;
      background: white;
      width: 18px; /* Maior para A e B */
      height: 18px;
      transform: translate(-9px, -9px);
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      text-align: center;
      line-height: 18px;
      font-weight: bold;
      color: var(--accent-3);
    }
    .geop-location-marker[style*="red"] {
      color: red;
    }
    
    /* trip-time styles */
    .trip-time{ width:96px; height:auto; min-height:96px; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:6px; border-radius:10px; font-size:14px; font-weight:700; cursor:pointer; background:#fff; border:1px solid #e6eef6; text-align:center; box-shadow:0 6px 18px rgba(2,6,23,0.03) }
    #scheduleContainer .trip-grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(96px,1fr)); gap:10px }
    #selectedRouteSchedule{ max-height:320px; overflow:auto }
    .trip-time:hover, .trip-time.selected{ background:var(--accent); color:white; border-color:var(--accent) }

    /* Roteiro A->B (Planner) */
    .route-option {
      padding: 10px;
      border: 1px solid #eef3fb;
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s; 
    }
    .route-option:hover {
      background: #f8fafc;
    }
    .route-option strong { color: var(--accent); }
    .route-option .details { font-size: 12px; color: var(--muted); margin-top: 4px; }


    /* Responsividade */
    @media (min-width: 981px) {
        #map{height:calc(100vh - 200px); min-height:300px; border-radius:12px}
        .container{height:calc(100vh - 120px);} 
    }

    @media (max-width:980px){
      .container{grid-template-columns:1fr;padding:12px; height:auto;}
      body{padding-top:140px}
      .header-content{ gap:10px; flex-direction:column; position:static; transform:none }
      header{ flex-direction:column; height:auto; padding:10px 0 }
      #top-right-controls{ position:static; margin-top:10px }
      header img{ height:50px; }
      
      .panel.controls{
        max-height: 60vh; 
      }
      #map{height:300px; min-height:300px; border-radius:12px}
    }
    
    /* Estilo para impress√£o */
    @media print {
      header, .panel.controls, .footer-legend, .auth-modal-backdrop, #top-right-controls { display:none !important; }
      body { padding-top: 0; background: white; color: black; }
      .container { display:block; padding: 0; max-width: none; }
      .panel { box-shadow: none; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
      #map { height: 400px !important; margin-bottom: 10px; }
      .leaflet-container { height: 100% !important; width: 100% !important; }
      .leaflet-control-container, .leaflet-control-zoom { display: none !important; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <img src="ASSETS/Incon Logo.png" alt="Icon Logo" class="icon-logo">
      <a href="#" class="logo-sim-link" title="SIM">
        <img src="ASSETS/Incon_Sim_1.png" alt="SIM Logo">
        <div style="font-size:14px; font-weight:700; color:var(--accent); text-align:center; margin-top:4px;">Sistema Integrado de Mobilidade de Contagem</div>
      </a>
    </div>

    <div id="top-right-controls">
      <div id="clock">--:--:--</div>
      <button id="sim-logout-btn" title="Sair da sess√£o interna">Sair</button>
    </div>
  </header>

  <div class="container">
    <div class="panel controls">
      <div class="tab-menu-wrapper">
        <button id="tabPlan" data-tab="plan" class="tab-btn active" style="flex:1">Planejador de Viagens</button>
        <button id="tabSearch" data-tab="search" class="tab-btn ghost" style="flex:1">Linhas & Hor√°rios</button>
        <button id="tabLocal" data-tab="local" class="tab-btn ghost" style="flex:1">GEOP</button>
        <button id="tabTools" data-tab="tools" class="tab-btn ghost" style="flex:1">Ferramentas</button>
      </div>

      <div id="tabContent">
        <div id="content-plan" class="tab-content">
          <h2>1. Buscar Itiner√°rio (A ‚Üí B)</h2>
          <div class="meta">Pesquise a melhor rota, incluindo baldea√ß√£o se necess√°rio, a partir do hor√°rio atual.</div>
          <div style="margin-top:10px">
            <div class="row"><input id="originInput" placeholder="Origem (Nome da parada GTFS ou endere√ßo)" list="stopsList" /></div>
            <div class="row"><input id="destInput" placeholder="Destino (Nome da parada GTFS ou endere√ßo)" list="stopsList" /></div>
            <datalist id="stopsList"></datalist>
            <div class="row"><label for="planDateInput" style="font-size:13px;color:var(--muted)">Data da Viagem:</label></div>
            <div class="row"><input type="date" id="planDateInput" style="flex:1" value=""></div>
            <div class="row">
              <button id="searchBtn" style="background:var(--accent-2); color:var(--accent)">Buscar Trajeto</button>
              <button id="clearBtn" class="ghost">Limpar Pesquisa</button>
            </div>
            <small class="note">A busca A‚ÜíB considera baldea√ß√£o e acesso/egresso a p√©.</small>
          </div>
          <hr style="margin:12px 0;border:none;border-top:1px solid #f0f4f8" />
          <div class="row" style="margin-bottom:12px"><button id="goToScheduleBtn" class="ghost" style="flex:1;background:#f6f9ff;color:var(--accent);border:none">Consultar Quadro de Hor√°rios ‚Üí</button></div>
          <div><h3>Op√ß√µes Encontradas (Com Hor√°rios)</h3><div id="routesBetween" class="route-list">Nenhuma pesquisa ainda.</div></div>
        </div>

        <div id="content-search" class="tab-content" style="display:none;">
          <h2>2. Quadro de Hor√°rios por Linha</h2>
          <div class="meta">Selecione uma linha e uma data para visualizar os hor√°rios de forma clara e elegante.</div>
          <div style="margin-top:10px">
            <div class="row">
              <select id="lineSearchSelect" style="flex:2"><option value="">Todas as Linhas</option></select>
              <button id="clearScheduleSearchBtn" class="ghost" style="flex:1">Limpar</button>
              <button id="searchLineBtn" style="flex:1">Buscar</button>
            </div>
            <div class="row"><label for="scheduleDateInput" style="font-size:13px;color:var(--muted)">Data do Quadro:</label></div>
            <div class="row"><input type="date" id="scheduleDateInput" style="flex:1" /></div>
            <small class="note">Linha: <span id="selectedLineName">(Todas)</span> - Dia: <span id="activeDayDisplay">...</span></small>
          </div>
          <hr style="margin:12px 0;border:none;border-top:1px solid #f0f4f8" />
          <div>
            <h3>Hor√°rios de Partida (Sentido)</h3>
            <div id="scheduleContainer">Carregue GTFS para ver viagens.</div>
            <div style="display:flex; gap:8px; margin-top:8px">
              <button id="btnLocateVehicle" class="ghost">Localizar Ve√≠culo (GPS)</button>
              <button id="btnNearestVehicle" class="ghost">Ve√≠culo mais pr√≥ximo</button>
              <button id="btnBackFromTrip" class="ghost" style="margin-left:auto; display:none">‚óÄ Voltar</button>
            </div>
          </div>
          <div style="margin-top:10px">
            <h3>Itiner√°rio & Pontos (Mapa)</h3>
            <div id="itinerary" class="itinerary">Selecione uma viagem para ver o itiner√°rio.</div>
          </div>
          <div style="margin-top:10px"><h3>Relat√≥rios de Viagem</h3>
            <div style="display:flex; gap:8px; margin-bottom:8px">
              <select id="reportTypeSelect" style="flex:1"><option value="delay">Atraso</option><option value="canceled">Cancelamento</option><option value="broken">Carro Quebrado</option><option value="other">Outro</option></select>
              <input id="reportNote" placeholder="Observa√ß√£o (opcional)" style="flex:2" />
              <button id="btnSendReport" class="ghost">Enviar Relat√≥rio</button>
            </div>
            <div id="reportsPanel">Nenhum relat√≥rio ainda.</div>
          </div>
        </div>

        <div id="content-local" class="tab-content" style="display:none;">
          <h2>3. Linhas Pr√≥ximas ao Local (GEOP)</h2>
          <div class="meta">Pesquise por **Logradouro (Rua, Av.)** ou **Coordenadas (Lat/Lon)**.</div>
          <div style="margin-top:10px">
            <div class="row">
              <input type="text" id="local-input-address" placeholder="Rua, Avenida, Beco ou Nome da Parada" style="flex:1" list="stopsList" />
              <button id="searchLocalBtn" class="ghost" style="flex:0; min-width:110px; margin-left:8px;">Buscar</button>
            </div>
            <div class="row" style="margin-top:8px; display:flex; gap:8px">
              <input type="text" id="lat-input" placeholder="Latitude (Ex: -19.92)" style="flex:1" oninput="formatCoordinate(this)"/>
              <input type="text" id="lon-input" placeholder="Longitude (Ex: -43.94)" style="flex:1" oninput="formatCoordinate(this)"/>
            </div>
            <div class="row" style="justify-content:space-between; margin-top:8px;">
              <button id="useGpsBtn" class="ghost" style="flex:1;background:#f6f9ff;color:var(--accent);border:none;margin-right:8px">Usar Minha Localiza√ß√£o (GPS)</button>
              <div style="flex:1;max-width:150px;display:flex">
                <span style="padding:10px 6px; background:#fff; border-radius:10px 0 0 10px; border:1px solid #eef3fb">Raio (m):</span>
                <input type="number" id="local-radius" value="500" min="50" max="2000" style="border-radius:0 10px 10px 0; border-left:none; flex:1" />
              </div>
            </div>
            <div id="local-result-message" style="margin-top:8px;color:var(--muted);font-size:13px">Insira um local para iniciar a busca.</div>
          </div>
          <hr style="margin:12px 0;border:none;border-top:1px solid #f0f4f8" />
          <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
            <button id="print-geop-btn" style="background:#005029; color:white; flex:1">Imprimir Resultados (PDF/A4)</button>
            <button id="clear-geop-btn" class="ghost" style="margin-left:8px;">Limpar GEOP</button>
          </div>
          <div style="max-height:400px; overflow-y:auto" id="nearby-lines-list"><p style="padding:16px;color:#64748b">Carregue GTFS e insira o local de busca.</p></div>
        </div>

        <div id="content-tools" class="tab-content" style="display:none;">
          <h2>4. Carregamento de Dados / Ferramentas</h2>
          <div class="meta">Os dados GTFS est√£o sendo carregados automaticamente da pasta `./GTFS/` na inicializa√ß√£o.</div>

          <div style="margin-top:8px; display:flex; align-items:center; gap:8px">
            <button id="loadBtn" class="ghost" style="flex:1">Recarregar GTFS (da pasta ./GTFS/)</button>
            <span id="gtfsStatus">Nenhum GTFS carregado.</span>
          </div>

          <hr style="margin:12px 0;border:none;border-top:1px solid #f0f4f8" />
          <div style="display:flex; justify-content:space-between; align-items:center">
            <h4>Fun√ß√µes Essenciais</h4>
            <div id="totalStopsCount">0 paradas</div>
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px">
            <button id="resetMapBtn" class="ghost">Redefinir Mapa/Paradas</button>
            <button class="ghost" disabled style="color:var(--muted)">Fun√ß√£o (A ser feita)</button>
          </div>
          
          <hr style="margin:12px 0;border:none;border-top:1px solid #f0f4f8" />
          <div id="employee-registration-section" style="display:none;">
              <h4>Cadastro de Funcion√°rio (Admin)</h4>
              <div class="meta">Crie uma nova conta de acesso Interno (Staff) ou Administrador.</div>
              <div style="margin-top:8px;">
                  <input type="text" id="new-user-name" placeholder="Nome de Usu√°rio (Ex: nome.sobrenome)" style="width:100%; margin-bottom:8px;" />
                  <input type="password" id="new-user-pass" placeholder="Senha" style="width:100%; margin-bottom:8px;" />
                  <select id="new-user-role" style="width:100%; margin-bottom:8px;">
                      <option value="staff">Funcion√°rio (Staff)</option>
                      <option value="admin">Administrador (Admin)</option>
                  </select>
                  <button id="registerUserBtn" style="width:100%;">Cadastrar Novo Usu√°rio</button>
                  <div id="registration-message" style="margin-top:8px; font-size:13px; color:var(--accent-3);"></div>
              </div>
          </div>
          </div>
      </div>

      <div style="margin-top:20px" class="footer-legend">
        <div style="background:var(--accent-2); color:var(--accent); font-weight:700; padding:6px 10px; border-radius:999px">Valor sugerido: R$ 6,40</div>
        <div class="small">Rotas integradas ao metr√¥ ser√£o sinalizadas.</div>
      </div>
    </div>

    <div>
      <div id="map" class="panel"></div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;padding:4px 10px;background:#fff;border-radius:12px;box-shadow:0 1px 6px rgba(2,6,23,0.04)">
        <label><input type="checkbox" id="toggleAllStops" checked /> Exibir todas as paradas (Cluster)</label>
        <div class="meta"><div id="searchSummary">Nenhuma pesquisa realizada ainda.</div></div>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <div class="panel" style="flex:1">
          <h4>Melhor op√ß√£o (Trajeto A‚ÜíB)</h4>
          <div id="bestOption">Busque rota para calcular.</div>
        </div>
      </div>
      <div id="selectedRouteSchedule" class="panel" style="margin-top:10px; display:none;">  
        <h4>Hor√°rios da linha selecionada</h4>
        <div class="small" style="color:var(--muted); margin-bottom:8px">Clique em 'Ver no Mapa' para exibir o tra√ßado e os hor√°rios aqui.</div>
        <div id="selectedRouteScheduleContent">Nenhuma linha selecionada.</div>
      </div>
    </div>
  </div>

  <footer style="text-align:center;padding:12px 8px;background:#fff;margin-top:20px;border-top:1px solid #eef2f7">
    <strong>GTFS ‚Äì Transporte Municipal de Contagem</strong>
    <div class="small">SIM ‚Äì Sistema Integrado de Mobilidade de Contagem ‚Äî Visor local</div>
  </footer>

  <div id="authBackdrop" class="auth-modal-backdrop" aria-hidden="true">
    <div class="auth-modal-content" style="background:#fff;padding:24px;border-radius:16px;box-shadow:0 10px 25px rgba(0,0,0,0.1);max-width:380px;width:90%">
      <h3 style="margin-top:0;color:var(--accent)">Acesso Interno SIM</h3>
      <div id="authMsg" style="color:#ff5c5c;margin-bottom:10px;font-size:13px;display:none"></div>
      <input id="authUser" placeholder="Usu√°rio (Ex: carloslima)" style="width:100%;margin-bottom:10px;text-transform:lowercase" />
      <input id="authPass" type="password" placeholder="Senha" style="width:100%;margin-bottom:15px" />
      <div style="display:flex;gap:10px">
        <button id="authOk" style="flex:1">Entrar</button>
        <button id="authCancel" class="ghost" style="flex:1">Cancelar</button>
      </div>
      <div style="font-size:12px;color:var(--muted);margin-top:15px;text-align:center">Acesso restrito para Staff/Admin.</div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

  <script>
  /************************************************************************
   * Inicializa√ß√£o: cria admin padr√£o (se n√£o existir)
   ************************************************************************/
  (function(){
    try {
      const users = JSON.parse(localStorage.getItem('sim_users')||'{}');
      if(!users['carloslima']){
        users['carloslima'] = { password: 'delima14delima', role:'admin', name:'Carlos Lima' };
        localStorage.setItem('sim_users', JSON.stringify(users));
      }
    } catch(e){ console.warn('init user error', e); }
  })();

  // Helpers
  const $ = id => document.getElementById(id);
  function show(el){ if(el) el.style.display=''; }
  function hide(el){ if(el) el.style.display='none'; }
  function pad(n){ return n<10?'0'+n:n; }

  // Clock
  function updateClock(){ const now = new Date(); $('clock').textContent = now.toLocaleTimeString('pt-BR', {hour12:false}); }
  setInterval(updateClock,1000); updateClock();

  // Map setup
  const map = L.map('map',{preferCanvas:true}).setView([-19.919, -44.052], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'¬© OpenStreetMap contributors'}).addTo(map);
  let routeLayer = L.layerGroup().addTo(map);
  let allStopsCluster = L.markerClusterGroup({ maxClusterRadius:80, chunkedLoading:true }).addTo(map);
  let currentLocationMarker = null; 
  let currentCircle = null; 

  // GTFS container
  let GTFS = { files:{}, stops:[], routes:[], trips:[], stop_times:[], shapes:[], calendar:[], calendar_dates:[] , shapesById: {}, stopsById:{}, tripsById:{}, routesById:{}, calendarMap:{} };

  // Utility functions
  function parseCSV(text){ return Papa.parse(text, { header:true, skipEmptyLines:true }).data; }
  function formatMinutes(mins){ if(mins==null) return '‚Äî'; if(mins<60) return mins+' min'; const h=Math.floor(mins/60), m=mins%60; return h+'h '+(m?m+'m':''); }
  function haversine(a,b){ const toRad=v=>v*Math.PI/180; const R=6371e3; const dlat=toRad(b.lat-a.lat), dlon=toRad(b.lon-a.lon), lat1=toRad(a.lat), lat2=toRad(b.lat); const sinlat=Math.sin(dlat/2), sinlon=Math.sin(dlon/2); const c=2*Math.atan2(Math.sqrt(sinlat*sinlat + Math.cos(lat1)*Math.cos(lat2)*sinlon*sinlon), Math.sqrt(1-(sinlat*sinlat + Math.cos(lat1)*Math.cos(lat2)*sinlon*sinlon))); return R*c; }
  
  function getCoordsFromStop(stop) {
      if(!stop || !stop.stop_lat || !stop.stop_lon) return [0, 0];
      return [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)];
  }

  /************************************************************************
   * NOVAS FUN√á√ïES: Planejador A->B e Tempo
   ************************************************************************/
  function findClosestStop(targetLocation) {
      if (!GTFS.stops || GTFS.stops.length === 0) return null;
      let closest = null;
      let minDistance = Infinity;

      GTFS.stops.forEach(s => {
          const stopLocation = { lat: parseFloat(s.stop_lat), lon: parseFloat(s.stop_lon) };
          const distance = haversine(targetLocation, stopLocation);
          if (distance < minDistance) {
              minDistance = distance;
              closest = { stop: s, distance: distance };
          }
      });
      return closest;
  }

  function timeToSeconds(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.split(':');
      if (parts.length < 2) return 0;
      let hours = parseInt(parts[0]);
      const minutes = parseInt(parts[1]);
      const seconds = parseInt(parts[2] || 0);
      return hours * 3600 + minutes * 60 + seconds;
  }

  function secondsToTime(totalSeconds) {
      const totalMinutes = Math.floor(totalSeconds / 60);
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }

  function getStopLocationByName(addressString){
      const lowerAddress = addressString.toLowerCase().trim();
      if(!GTFS.stops) return null;
      const foundStop = GTFS.stops.find(s => s.stop_name && s.stop_name.toLowerCase() === lowerAddress) ||
                        GTFS.stops.find(s => s.stop_name && s.stop_name.toLowerCase().includes(lowerAddress));
      if(foundStop && foundStop.stop_lat && foundStop.stop_lon){
          return {
              lat: parseFloat(foundStop.stop_lat),
              lon: parseFloat(foundStop.stop_lon),
              name: foundStop.stop_name
          };
      }
      return null;
  }
  
  /************************************************************************
   * AJUSTE GEOP: Formata√ß√£o de Lat/Lon
   ************************************************************************/
  function formatCoordinate(input) {
    let value = input.value.replace(/[^\d\.\-]/g, ''); 
    if ((value.match(/\./g) || []).length > 1) {
        value = value.substring(0, value.lastIndexOf('.'));
    }
    if(value.length > 1 && value.startsWith('-') && value.lastIndexOf('-') > 0) {
        value = value.substring(0, value.lastIndexOf('-'));
    }
    if (value.length > 15) { 
        value = value.substring(0, 15);
    }
    input.value = value;
  }
  window.formatCoordinate = formatCoordinate; 

  /************************************************************************
   * AUTH (modal) e CADASTRO DE FUNCION√ÅRIOS (Admin Only)
   ************************************************************************/
  const authBackdrop = $('authBackdrop'), authUser = $('authUser'), authPass = $('authPass'), authOk = $('authOk'), authCancel = $('authCancel');
  const logoutBtn = $('sim-logout-btn');

  function showAuthMessage(msg){ const el=$('authMsg'); if(msg){ el.style.display='block'; el.textContent = msg; } else { el.style.display='none'; el.textContent=''; } }
  function openAuthModal(purpose){
    showAuthMessage(''); authUser.value=''; authPass.value='';
    authBackdrop.style.display='flex'; authBackdrop.setAttribute('aria-hidden','false');
    authBackdrop.dataset.purpose = purpose || ''; setTimeout(()=>authUser.focus(),50);
  }
  function closeAuthModal(){ authBackdrop.style.display='none'; authBackdrop.setAttribute('aria-hidden','true'); authBackdrop.dataset.purpose=''; }
  function setSession(role, username){
    sessionStorage.setItem('sim_role', role); sessionStorage.setItem('sim_user', username||''); updateAuthUI();
  }
  function clearSession(){
    sessionStorage.removeItem('sim_role'); sessionStorage.removeItem('sim_user'); updateAuthUI();
  }

  function updateAuthUI(){
    const role = sessionStorage.getItem('sim_role') || 'public';
    const user = sessionStorage.getItem('sim_user') || '';
    if(role==='staff' || role==='admin'){ $('sim-logout-btn').style.display='inline-block'; }
    else { $('sim-logout-btn').style.display='none'; }
    updateRegistrationUI(); 
  }

  const registrationSection = $('employee-registration-section');
  const registerUserBtn = $('registerUserBtn');
  const regMsg = $('registration-message');

  function updateRegistrationUI(){
    const role = sessionStorage.getItem('sim_role') || 'public';
    if(role === 'admin'){ show(registrationSection); } else { hide(registrationSection); }
  }

  registerUserBtn.addEventListener('click', function(){
    const username = $('new-user-name').value.trim().toLowerCase().replace(/\s/g, '').replace(/\./g, ''); 
    const password = $('new-user-pass').value;
    const role = $('new-user-role').value;
    regMsg.textContent = '';
    if(!username || !password){ regMsg.textContent = 'Preencha usu√°rio e senha.'; regMsg.style.color='#ff5c5c'; return; }
    try {
      const users = JSON.parse(localStorage.getItem('sim_users') || '{}');
      if(users[username]){ regMsg.textContent = `Usu√°rio "${username}" j√° existe!`; regMsg.style.color='#ff5c5c'; return; }
      users[username] = { password: password, role: role, name: username.toUpperCase().replace(/\./g, ' ') };
      localStorage.setItem('sim_users', JSON.stringify(users));
      regMsg.textContent = `Usu√°rio ${username} (${role}) cadastrado com sucesso!`;
      regMsg.style.color='var(--accent-3)';
      $('new-user-name').value = ''; $('new-user-pass').value = '';
      updateRegistrationUI(); 
    } catch(e){ console.error('Registration error', e); regMsg.textContent = 'Erro ao cadastrar usu√°rio.'; regMsg.style.color='#ff5c5c'; }
  });

  authOk.addEventListener('click', function(){
    const u = authUser.value.trim().toLowerCase().replace(/\s/g, '').replace(/\./g, ''); 
    const p = authPass.value;
    if(!u || !p){ showAuthMessage('Informe usu√°rio e senha.'); return; }
    try {
      const users = JSON.parse(localStorage.getItem('sim_users') || '{}');
      const uu = users[u];
      if(uu && uu.password === p){
        const role = uu.role === 'admin' ? 'admin' : 'staff';
        setSession(role, u);
        closeAuthModal();
        const purpose = authBackdrop.dataset.purpose || '';
        if(purpose){ const btn = document.querySelector('[data-tab="'+purpose+'"]'); if(btn) activateTabButton(btn); }
        updateRegistrationUI(); 
        return;
      } else { showAuthMessage('Usu√°rio ou senha inv√°lidos.'); }
    } catch(e){ console.error('auth error', e); showAuthMessage('Erro ao validar usu√°rio.'); }
  });
  authCancel.addEventListener('click', ()=>closeAuthModal());
  authBackdrop.addEventListener('click', e => { if(e.target===authBackdrop) closeAuthModal(); });
  logoutBtn.addEventListener('click', function(){ if(!confirm('Deseja encerrar a sess√£o interna?')) return; clearSession(); location.reload(); });
  updateAuthUI(); 

  /************************************************************************
   * Limpeza e troca de abas
   ************************************************************************/
  function clearMapLayers(){
    routeLayer.clearLayers();
    if(currentLocationMarker) currentLocationMarker.remove();
    if(currentCircle) currentCircle.remove();
    currentLocationMarker = null;
    currentCircle = null;
    map.setView([-19.919, -44.052], 12); 
  }

  function clearAllTabs(){ 
    clearMapLayers();
    $('searchSummary').textContent = 'Nenhuma pesquisa realizada ainda.';

    // Limpa Plan tab
    $('originInput').value = ''; $('destInput').value = '';
    $('routesBetween').innerHTML = 'Nenhuma pesquisa ainda.';
    $('bestOption').innerHTML = 'Busque rota para calcular.';
    currentItineraries = [];
    currentOriginStop = null;
    currentDestStop = null;

    // Limpa Search tab
    $('lineSearchSelect').value = '';
    $('scheduleContainer').innerHTML = 'Carregue GTFS para ver viagens.';
    $('selectedLineName').textContent = '(Todas)';
    $('itinerary').innerHTML = 'Selecione uma viagem para ver o itiner√°rio.';
    hide($('selectedRouteSchedule'));

    // Limpa Local tab (GEOP)
    $('local-input-address').value = '';
    $('lat-input').value = '';
    $('lon-input').value = '';
    $('local-result-message').textContent = 'Insira um local para iniciar a busca.';
    $('nearby-lines-list').innerHTML = '<p style="padding:16px;color:#64748b">Carregue GTFS e insira o local de busca.</p>';
  }
  
  function activateTabButton(button){
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active', 'ghost'));
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.add('ghost'));
      button.classList.remove('ghost');
      button.classList.add('active');

      document.querySelectorAll('.tab-content').forEach(content => hide(content));
      show($(`content-${button.dataset.tab}`));
      
      clearAllTabs(); 
      
      if(button.dataset.tab === 'search'){
        updateDayTypeDisplay();
      }
  }


  /************************************************************************
   * GTFS Loading
   ************************************************************************/
  const gtfsRelativeFolder = './GTFS/';
  const expectedFiles = ['stops.txt','routes.txt','trips.txt','stop_times.txt','shapes.txt','calendar.txt','calendar_dates.txt'];

  function applyLoadedGTFS(loaded, sourceLabel){
    ['stops','routes','trips','stop_times','shapes','calendar','calendar_dates','fare_attributes','frequencies'].forEach(k=>{
      if(loaded[k]) GTFS[k] = loaded[k];
    });

    GTFS.stopsById = {};
    if(GTFS.stops) GTFS.stops.forEach(s => GTFS.stopsById[s.stop_id]=s);

    GTFS.tripsById = {};
    if(GTFS.trips) GTFS.trips.forEach(t => GTFS.tripsById[t.trip_id]=t);

    GTFS.routesById = {};
    if(GTFS.routes) GTFS.routes.forEach(r => GTFS.routesById[r.route_id]=r);

    GTFS.stopTimesByTrip = {};
    if(GTFS.stop_times) GTFS.stop_times.forEach(st=>{
      if(!GTFS.stopTimesByTrip[st.trip_id]) GTFS.stopTimesByTrip[st.trip_id]=[];
      GTFS.stopTimesByTrip[st.trip_id].push(st);
    });
    for(const k in GTFS.stopTimesByTrip) GTFS.stopTimesByTrip[k].sort((a,b)=>parseInt(a.stop_sequence)-parseInt(b.stop_sequence));

    GTFS.shapesById = {};
    if(GTFS.shapes) GTFS.shapes.forEach(s => {
      if(!GTFS.shapesById[s.shape_id]) GTFS.shapesById[s.shape_id]=[];
      GTFS.shapesById[s.shape_id].push([parseFloat(s.shape_pt_lat), parseFloat(s.shape_pt_lon)]);
    });
    for(const k in GTFS.shapesById) GTFS.shapesById[k].sort((a,b)=>a.shape_pt_sequence-b.shape_pt_sequence);

    // Index calendar/calendar_dates
    GTFS.calendarMap = {};
    if(GTFS.calendar) GTFS.calendar.forEach(c => {
        const days = [];
        if(c.sunday==1) days.push(0); if(c.monday==1) days.push(1); if(c.tuesday==1) days.push(2); if(c.wednesday==1) days.push(3);
        if(c.thursday==1) days.push(4); if(c.friday==1) days.push(5); if(c.saturday==1) days.push(6);
        GTFS.calendarMap[c.service_id] = { days: days, start: c.start_date, end: c.end_date };
    });

    // Populate UI
    renderStopsOnMap();
    populateLineSelects();
    setupDateListeners();
    $('gtfsStatus').textContent = `Dados carregados (${sourceLabel} - ${GTFS.stops.length} paradas)`;
    $('totalStopsCount').textContent = `${GTFS.stops.length} paradas`;
    
    // Popula a datalist de Autocomplete (GEOP/Planner)
    const stopsList = $('stopsList');
    stopsList.innerHTML = ''; 
    GTFS.stops.forEach(stop => {
      if(stop.stop_name) {
        const option = document.createElement('option');
        option.value = stop.stop_name;
        stopsList.appendChild(option);
      }
    });

    if ($('tabLocal').classList.contains('active')) {
      const latInput = $('lat-input').value.trim();
      const lonInput = $('lon-input').value.trim();
      if (latInput && lonInput) {
        $('searchLocalBtn').click();
      }
    }
  }

  async function tryLoadGTFSFromRelative(){
    try {
      const resp = await fetch(gtfsRelativeFolder + 'stops.txt', {cache:'no-cache'});
      if(!resp.ok) throw new Error('not found');
      
      const loaded = {};
      for(const fn of expectedFiles){
        try {
          const r = await fetch(gtfsRelativeFolder + fn, {cache:'no-cache'});
          if(r.ok){
            const text = await r.text();
            const key = fn.split('/').pop().replace('.txt','');
            loaded[key] = parseCSV(text);
          }
        } catch(e){}
      }
      applyLoadedGTFS(loaded, 'relativo');
      return true;
    } catch(e){
      // ERRO CR√çTICO: Se a primeira leitura falhar, exibe a mensagem de erro no status
      console.error('Erro ao carregar GTFS. Verifique se a pasta ./GTFS/ existe e se est√° usando um servidor local (ex: http://localhost:8000).', e);
      $('gtfsStatus').innerHTML = 'üî¥ Erro de Carga! (Faltando GTFS ou Servidor Local?)';
      return false;
    }
  }

  /************************************************************************
   * MAP & UI rendering
   ************************************************************************/

  function renderStopsOnMap(){
    allStopsCluster.clearLayers();
    if(!GTFS.stops || GTFS.stops.length === 0) return;

    GTFS.stops.forEach(stop => {
      const marker = L.marker([stop.stop_lat, stop.stop_lon]).bindPopup(`<b>${stop.stop_name}</b><br>${stop.stop_desc||''}<br>ID: ${stop.stop_id}`);
      allStopsCluster.addLayer(marker);
    });
    map.fitBounds(allStopsCluster.getBounds());
  }

  function populateLineSelects(){
    const select = $('lineSearchSelect');
    select.innerHTML = '<option value="">Todas as Linhas</option>';
    GTFS.routes.forEach(route => {
      const option = document.createElement('option');
      option.value = route.route_id;
      option.textContent = `${route.route_short_name} - ${route.route_long_name}`;
      select.appendChild(option);
    });
  }
  
  /************************************************************************
   * ROUTE & SCHEDULE (Drawings)
   ************************************************************************/
  let currentRoutePolyline = null;
  let currentRouteStops = L.layerGroup();
  
  // AJUSTE: Tra√ßado em VERMELHO para a aba Linhas & Hor√°rios
  function drawRoutePolylineByRoute(routeId, colorHex='FF0000'){ // Default: RED para a aba Search
    routeLayer.clearLayers(); 
    
    const trip = GTFS.trips.find(t => t.route_id === routeId);
    if(!trip || !trip.shape_id || !GTFS.shapesById[trip.shape_id]){
      console.warn(`N√£o foi poss√≠vel encontrar shape para a rota ${routeId}`);
      routeLayer.removeLayer(currentRouteStops);
      return;
    }

    const shape = GTFS.shapesById[trip.shape_id];
    
    if(currentRoutePolyline) routeLayer.removeLayer(currentRoutePolyline);
    
    // Desenha o tra√ßado com maior espessura e opacidade
    currentRoutePolyline = L.polyline(shape, {
        color: `#${colorHex.replace('#','')}`, 
        weight: 7, 
        opacity: 0.9 
    }).addTo(routeLayer);
    
    // Adiciona os stops no mapa com marcadores mais vis√≠veis
    currentRouteStops.clearLayers();
    const stopsForTrip = GTFS.stopTimesByTrip[trip.trip_id] || [];
    stopsForTrip.forEach(st => {
        const stop = GTFS.stopsById[st.stop_id];
        if(stop){
            L.circleMarker([stop.stop_lat, stop.stop_lon], {
                radius: 6, 
                color: 'white',
                fillColor: `#${colorHex.replace('#','')}`,
                fillOpacity: 1,
                weight: 3 
            }).addTo(routeLayer) 
            .bindPopup(`<b>${stop.stop_name}</b><br>Hor√°rio: ${st.arrival_time ? st.arrival_time.substring(0,5) : '‚Äî'}`);
        }
    });

    map.fitBounds(currentRoutePolyline.getBounds().pad(0.1));
  }
  
  /************************************************************************
   * AJUSTE GEOP: Fun√ß√µes
   ************************************************************************/
  
  function findNearbyStops(lat, lon, radius) {
    const target = { lat: lat, lon: lon };
    const nearby = [];
    if(!GTFS.stops) return nearby;

    GTFS.stops.forEach(s => {
        const stopLocation = { lat: parseFloat(s.stop_lat), lon: parseFloat(s.stop_lon) };
        const distance = haversine(target, stopLocation);
        if (distance <= radius) {
            nearby.push({ stop: s, distance: distance });
        }
    });
    return nearby.sort((a, b) => a.distance - b.distance);
  }

  function findNearbyLines(nearbyStops) {
    const lineSet = new Map(); 
    if(!GTFS.routes) return [];

    nearbyStops.forEach(item => {
        const tripsPassing = GTFS.stop_times.filter(st => st.stop_id === item.stop.stop_id).map(st => GTFS.tripsById[st.trip_id]).filter(t=>t);
        
        tripsPassing.forEach(trip => {
            if(trip && GTFS.routesById[trip.route_id]) {
                const route = GTFS.routesById[trip.route_id];
                const routeId = route.route_id;

                if (!lineSet.has(routeId) || item.distance < lineSet.get(routeId).minDistance) {
                    lineSet.set(routeId, { route: route, minDistance: item.distance });
                }
            }
        });
    });

    const lines = Array.from(lineSet.values());
    lines.sort((a, b) => a.minDistance - b.minDistance);
    return lines;
  }

  // L√≥gica de busca e prioridade ATUALIZADA para GEOP
  $('searchLocalBtn').addEventListener('click', ()=>{
    const latInputEl = $('lat-input');
    const lonInputEl = $('lon-input');
    const addressInput = $('local-input-address').value.trim();
    const radius = parseFloat($('local-radius').value) || 500;
    
    let lat = null, lon = null;
    let searchSource = '';
    let errorMsg = '';

    const latInput = latInputEl.value.trim();
    const lonInput = lonInputEl.value.trim();

    if (latInput && lonInput) {
      const parsedLat = parseFloat(latInput);
      const parsedLon = parseFloat(lonInput);
      if (isNaN(parsedLat) || isNaN(parsedLon) || parsedLat < -90 || parsedLat > 90 || parsedLon < -180 || parsedLon > 180) {
        errorMsg = 'Erro: Coordenadas Lat/Lon inv√°lidas nos campos. Verifique o formato.';
      } else {
        lat = parsedLat;
        lon = parsedLon;
        searchSource = `Coordenadas (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
      }
    }

    if (lat === null && lon === null && addressInput) {
      const locationFromStop = getStopLocationByName(addressInput);
      
      if (locationFromStop) {
        lat = locationFromStop.lat;
        lon = locationFromStop.lon;
        searchSource = `Parada GTFS Encontrada: ${locationFromStop.name}`;
        
        latInputEl.value = lat.toFixed(6);
        lonInputEl.value = lon.toFixed(6);
        
      } else {
        errorMsg = 'Aviso: N√£o foi poss√≠vel localizar uma Parada GTFS para o endere√ßo informado. Tente ajustar o texto ou utilize as coordenadas.';
      }
    }
    
    // AJUSTE: Cor do marcador para GEOP
    const customIcon = L.divIcon({ className: 'geop-location-marker' });

    if (errorMsg) {
      $('local-result-message').textContent = errorMsg;
      $('nearby-lines-list').innerHTML = `<p style="padding:16px;color:#ff5c5c">${errorMsg}</p>`;
      clearMapLayers();
      return;
    }
    if (lat === null || lon === null) {
      $('local-result-message').textContent = 'Erro: Insira um endere√ßo v√°lido ou as coordenadas (Lat/Lon).';
      $('nearby-lines-list').innerHTML = `<p style="padding:16px;color:#ff5c5c">Erro: Insira um endere√ßo v√°lido ou as coordenadas.</p>`;
      clearMapLayers();
      return;
    }

    clearMapLayers();
    const location = [lat, lon];
    
    currentLocationMarker = L.marker(location, { icon: customIcon }).addTo(routeLayer);
    
    currentCircle = L.circle(location, { 
      radius: radius, 
      color: '#1E90FF', 
      fillColor: '#1E90FF', 
      fillOpacity: 0.1, 
      dashArray: '8, 8' 
    }).addTo(routeLayer);
    
    map.fitBounds(currentCircle.getBounds().pad(0.2));

    const nearbyStops = findNearbyStops(lat, lon, radius);
    const nearbyLines = findNearbyLines(nearbyStops);

    const listContainer = $('nearby-lines-list');
    $('local-result-message').textContent = `Local: ${searchSource} - ${nearbyLines.length} linhas encontradas em ${nearbyStops.length} paradas no raio de ${radius}m.`;
    
    if(nearbyLines.length === 0){
      listContainer.innerHTML = `<p style="padding:16px;color:#ff5c5c">Nenhuma linha encontrada no raio de ${radius} metros.</p>`;
      return;
    }
    
    listContainer.innerHTML = nearbyLines.map(line => {
      const route = line.route;
      // Passa a cor do GTFS, mas se n√£o tiver, o drawRoutePolylineByRoute usar√° o vermelho padr√£o (para a aba SEARCH/GEOP).
      const color = route.route_color || 'FF0000'; 
      return `<div class="list-group-item" data-route-id="${route.route_id}" onclick="drawRoutePolylineByRoute('${route.route_id}', '${color}'); this.style.backgroundColor='var(--accent-2)'"> 
        <div>
          <span class="line-code" style="color:#${color}">${route.route_short_name}</span> ${route.route_long_name}
        </div>
        <div style="font-size:12px; color:var(--muted)">${line.minDistance.toFixed(0)}m (Parada mais pr√≥xima)</div>
      </div>`;
    }).join('');

    nearbyStops.forEach(item => {
      const s = item.stop;
      L.marker([s.stop_lat, s.stop_lon], { opacity: 0.8 }).addTo(routeLayer)
      .bindPopup(`<b>${s.stop_name}</b><br>${item.distance.toFixed(0)}m de dist√¢ncia`);
    });
  });

  $('clear-geop-btn').addEventListener('click', clearAllTabs);
  $('print-geop-btn').addEventListener('click', ()=>{ window.print(); });
  
  /************************************************************************
   * RESTAURA√á√ÉO: Schedule/Search Logic
   ************************************************************************/
  function formatTime(timeStr) { 
      if (!timeStr) return '‚Äî';
      const parts = timeStr.split(':');
      if (parts.length >= 2) return `${parts[0].padStart(2, '0')}:${parts[1]}`;
      return timeStr;
  }

  function renderSchedule(routeId, dateStr) {
    const scheduleContainer = $('scheduleContainer');
    scheduleContainer.innerHTML = '';
    hide($('selectedRouteSchedule'));

    if (!GTFS.routesById[routeId]) {
        scheduleContainer.innerHTML = 'Selecione uma linha e carregue o GTFS.';
        return;
    }

    const dayInfo = determineDayType(dateStr);
    const dayIndex = dayInfo.dayIndex;

    const tripsForRoute = GTFS.trips.filter(t => t.route_id === routeId);
    if (tripsForRoute.length === 0) {
        scheduleContainer.innerHTML = 'Nenhuma viagem encontrada para esta linha.';
        return;
    }

    const container = document.createElement('div');
    container.className = 'trip-grid';
    const uniqueTrips = new Set();
    
    const tripsByHeadsign = {};
    tripsForRoute.forEach(trip => {
        const service = GTFS.calendarMap[trip.service_id];
        if (service && service.days.includes(dayIndex)) {
            const headsign = trip.trip_headsign || 'Viagem Sem Sentido';
            if (!tripsByHeadsign[headsign]) {
                tripsByHeadsign[headsign] = [];
            }
            const firstStopTime = GTFS.stopTimesByTrip[trip.trip_id] ? GTFS.stopTimesByTrip[trip.trip_id][0] : null;
            if (firstStopTime) {
                const startTime = firstStopTime.departure_time;
                if (!uniqueTrips.has(startTime)) {
                    uniqueTrips.add(startTime);
                    tripsByHeadsign[headsign].push({ time: startTime, trip: trip });
                }
            }
        }
    });

    for (const headsign in tripsByHeadsign) {
        const group = document.createElement('div');
        group.style.gridColumn = '1 / -1';
        group.innerHTML = `<h4 style="margin-top:10px; margin-bottom:5px; border-bottom:1px solid #f0f4f8; padding-bottom:5px;">Sentido: ${headsign}</h4>`;
        container.appendChild(group);

        tripsByHeadsign[headsign].sort((a, b) => a.time.localeCompare(b.time));

        tripsByHeadsign[headsign].forEach(item => {
            const timeEl = document.createElement('div');
            timeEl.className = 'trip-time';
            timeEl.dataset.tripId = item.trip.trip_id;
            timeEl.innerHTML = `<span>${formatTime(item.time)}</span><span style="font-size:11px; font-weight:400; color:inherit;">Ver no Mapa</span>`;
            timeEl.addEventListener('click', () => viewTripDetails(item.trip.trip_id));
            container.appendChild(timeEl);
        });
    }

    if (container.children.length === 0) {
        scheduleContainer.innerHTML = 'Nenhuma viagem agendada para este dia/linha.';
    } else {
        scheduleContainer.appendChild(container);
    }
  }

  function viewTripDetails(tripId) {
      const trip = GTFS.tripsById[tripId];
      const route = GTFS.routesById[trip.route_id];
      const stopTimes = GTFS.stopTimesByTrip[tripId] || [];
      
      document.querySelectorAll('.trip-time').forEach(el => el.classList.remove('selected'));
      document.querySelector(`[data-trip-id="${tripId}"]`).classList.add('selected');
      show($('selectedRouteSchedule'));

      // AJUSTE: For√ßa a cor VERMELHA para a aba Linhas & Hor√°rios
      const color = 'FF0000'; 
      drawRoutePolylineByRoute(route.route_id, color);
      
      const itineraryHtml = `
          <h4>Itiner√°rio Detalhado - ${trip.trip_headsign || route.route_long_name}</h4>
          <table style="width:100%; border-collapse:collapse; font-size:13px;">
              <thead>
                  <tr style="background:#f4f7fb;">
                      <th style="padding:5px; text-align:left;">Ordem</th>
                      <th style="padding:5px; text-align:left;">Parada</th>
                      <th style="padding:5px; text-align:right;">Chegada</th>
                      <th style="padding:5px; text-align:right;">Partida</th>
                  </tr>
              </thead>
              <tbody>
                  ${stopTimes.map(st => {
                      const stop = GTFS.stopsById[st.stop_id];
                      return `
                          <tr>
                              <td style="padding:5px; border-bottom:1px solid #eef3fb;">${st.stop_sequence}</td>
                              <td style="padding:5px; border-bottom:1px solid #eef3fb;">${stop ? stop.stop_name : st.stop_id}</td>
                              <td style="padding:5px; border-bottom:1px solid #eef3fb; text-align:right;">${formatTime(st.arrival_time)}</td>
                              <td style="padding:5px; border-bottom:1px solid #eef3fb; text-align:right;">${formatTime(st.departure_time)}</td>
                          </tr>
                      `;
                  }).join('')}
              </tbody>
          </table>
      `;
      $('itinerary').innerHTML = itineraryHtml;
      $('selectedRouteScheduleContent').innerHTML = itineraryHtml; 
  }

  $('searchLineBtn').addEventListener('click', () => {
      const routeId = $('lineSearchSelect').value;
      const dateStr = $('scheduleDateInput').value;
      if (routeId && dateStr) {
          renderSchedule(routeId, dateStr);
          const route = GTFS.routesById[routeId];
          $('selectedLineName').textContent = `${route.route_short_name} - ${route.route_long_name}`;
          const firstTrip = GTFS.trips.find(t => t.route_id === routeId);
          if (firstTrip) {
            // AJUSTE: For√ßa a cor VERMELHA para a aba Linhas & Hor√°rios
            const color = 'FF0000';
            drawRoutePolylineByRoute(routeId, color);
          }
      } else {
          alert('Por favor, selecione uma linha e uma data.');
      }
  });

  $('clearScheduleSearchBtn').addEventListener('click', () => {
    $('lineSearchSelect').value = '';
    $('scheduleContainer').innerHTML = 'Carregue GTFS para ver viagens.';
    $('selectedLineName').textContent = '(Todas)';
    $('itinerary').innerHTML = 'Selecione uma viagem para ver o itiner√°rio.';
    hide($('selectedRouteSchedule'));
    routeLayer.clearLayers();
  });
  
  /************************************************************************
   * AJUSTE PRINCIPAL: Planner Logic (A -> B)
   ************************************************************************/
  
  let currentItineraries = []; // Vari√°vel global para armazenar os resultados da busca
  let currentOriginStop = null; // Vari√°vel global para a parada de origem GTFS
  let currentDestStop = null; // Vari√°vel global para a parada de destino GTFS

  function findItineraries(originName, destName, dateStr) {
      const timeNow = new Date();
      // Start time in seconds (from midnight, potentially beyond 23:59:59 if we wrap)
      const startTimeSeconds = timeNow.getHours() * 3600 + timeNow.getMinutes() * 60; 
      const dayInfo = determineDayType(dateStr);
      const dayIndex = dayInfo.dayIndex;
      
      const MAX_WAIT_TIME_MINS = 45; // Max 45 minutes of waiting at transfer stop

      // Step 1: Find Stop Locations (Using basic GTFS stop name match for coordinates)
      const originLoc = getStopLocationByName(originName);
      const destLoc = getStopLocationByName(destName);
      
      if (!originLoc || !destLoc) return { closestOriginStop: null, closestDestStop: null, itineraries: [] };
      
      // Step 2: Find Closest GTFS Stops to the coordinates found (to estimate walk time)
      const closestOriginStop = findClosestStop(originLoc);
      const closestDestStop = findClosestStop(destLoc);

      if (!closestOriginStop || !closestDestStop) return { closestOriginStop: null, closestDestStop: null, itineraries: [] };
      
      currentOriginStop = closestOriginStop;
      currentDestStop = closestDestStop;

      const originStop = closestOriginStop.stop;
      const destStop = closestDestStop.stop;
      
      // Walk time calculation: Distance (m) / 1.1 m/s (walk speed) + 5 min buffer (seconds to minutes)
      const walkTimeOrigin = Math.ceil(closestOriginStop.distance / 1.1 / 60) + 5; 
      const walkTimeDest = Math.ceil(closestDestStop.distance / 1.1 / 60) + 5;
      
      let allItineraries = [];
      
      // Optimization: Filter stop times only for the current day
      const stopTimesToday = GTFS.stop_times.filter(st => {
          const trip = GTFS.tripsById[st.trip_id];
          return trip && GTFS.calendarMap[trip.service_id] && GTFS.calendarMap[trip.service_id].days.includes(dayIndex);
      });

      // --------------------------------------------------------
      // 1. BUSCA DIRETA (0 TRANSFER)
      // --------------------------------------------------------
      
      const directTrips = GTFS.trips.filter(t => GTFS.routesById[t.route_id] && GTFS.calendarMap[t.service_id] && GTFS.calendarMap[t.service_id].days.includes(dayIndex));
      
      directTrips.forEach(trip => {
          const stopTimes = GTFS.stopTimesByTrip[trip.trip_id];
          if (!stopTimes) return;

          const originST = stopTimes.find(st => st.stop_id === originStop.stop_id);
          const destST = stopTimes.find(st => st.stop_id === destStop.stop_id);
          
          if (originST && destST && parseInt(originST.stop_sequence) < parseInt(destST.stop_sequence)) {
              // Found a direct route!
              const tripDepartureTimeSeconds = timeToSeconds(originST.departure_time);
              
              // Calculate when the user must arrive at the bus stop (tripDepartureTimeSeconds - walkTimeOrigin)
              const requiredArrivalAtStopSeconds = tripDepartureTimeSeconds - (walkTimeOrigin * 60);

              // Check if the trip is available now (i.e., user can get to stop before departure)
              if (requiredArrivalAtStopSeconds >= startTimeSeconds) { 
                  
                  const arrivalTimeDestSeconds = timeToSeconds(destST.arrival_time);
                  
                  const busTime = (arrivalTimeDestSeconds - tripDepartureTimeSeconds) / 60; 
                  
                  // Total time from NOW (current time) to arrival at final destination (including final walk)
                  const totalTime = (arrivalTimeDestSeconds - startTimeSeconds) / 60 + walkTimeDest;
                  
                  // Estimated Bus Stop Departure Time (HH:MM)
                  const depTimeDisplay = secondsToTime(tripDepartureTimeSeconds);
                  // Estimated Final Arrival Time (HH:MM)
                  const arrivalTimeDisplay = secondsToTime(arrivalTimeDestSeconds + (walkTimeDest * 60));

                  allItineraries.push({
                      transfers: 0,
                      totalTime: totalTime, 
                      departureTime: depTimeDisplay,
                      arrivalTime: arrivalTimeDisplay,
                      segments: [{
                          type: 'Walk to Origin', duration: formatMinutes(walkTimeOrigin), details: `üö∂ Caminhe at√© ${originStop.stop_name}`
                      }, {
                          type: 'Bus', route: GTFS.routesById[trip.route_id], from: originStop, to: destStop, trip: trip, 
                          departure: depTimeDisplay, arrival: secondsToTime(arrivalTimeDestSeconds), duration: formatMinutes(busTime)
                      }, {
                          type: 'Walk to Destination', duration: formatMinutes(walkTimeDest), details: `üö∂ Caminhe de ${destStop.stop_name} ao destino final`
                      }]
                  });
              }
          }
      });


      // --------------------------------------------------------
      // 2. BUSCA COM 1 BALDEA√á√ÉO (1 TRANSFER)
      // --------------------------------------------------------

      // 2a. Find all trips departing from the origin stop
      const tripsFromOrigin = stopTimesToday.filter(st => st.stop_id === originStop.stop_id)
          .map(st => ({ 
              st: st, 
              trip: GTFS.tripsById[st.trip_id] 
          }));
      
      // 2b. Iterate over the first bus trips
      tripsFromOrigin.forEach(item1 => {
          const trip1 = item1.trip;
          const st1_origin = item1.st;
          const route1 = GTFS.routesById[trip1.route_id];
          const trip1DepartureTimeSeconds = timeToSeconds(st1_origin.departure_time);

          // Check if the user can catch this bus 1
          if (trip1DepartureTimeSeconds - (walkTimeOrigin * 60) < startTimeSeconds) return;

          const trip1StopTimes = GTFS.stopTimesByTrip[trip1.trip_id];
          if (!trip1StopTimes) return;

          // 2c. Iterate over all subsequent stops on the first trip (potential transfer stops)
          trip1StopTimes.forEach(st1_transfer => {
              if (parseInt(st1_transfer.stop_sequence) <= parseInt(st1_origin.stop_sequence)) return;
              
              const transferStop1 = GTFS.stopsById[st1_transfer.stop_id];
              
              // Bus 1 Arrival Time at Transfer Stop (seconds)
              const arrivalTimeTransferSeconds = timeToSeconds(st1_transfer.arrival_time);

              // 2d. Find trips departing from the transfer stop (Bus 2)
              const tripsFromTransfer = stopTimesToday.filter(st => st.stop_id === transferStop1.stop_id)
                  .map(st => ({ 
                      st: st, 
                      trip: GTFS.tripsById[st.trip_id] 
                  }))
                  .filter(item2 => item2.trip.route_id !== trip1.route_id); // Must be a different line
              
              tripsFromTransfer.forEach(item2 => {
                  const trip2 = item2.trip;
                  const st2_transfer = item2.st;
                  const route2 = GTFS.routesById[trip2.route_id];

                  // Bus 2 Departure Time from Transfer Stop (seconds)
                  const departureTimeTransferSeconds = timeToSeconds(st2_transfer.departure_time);

                  // Wait Time Calculation (seconds)
                  let waitTimeSeconds = departureTimeTransferSeconds - arrivalTimeTransferSeconds;

                  // Adjust for trips spanning midnight 
                  if (waitTimeSeconds < 0) {
                      waitTimeSeconds += 24 * 3600; 
                  }
                  const waitTimeMins = waitTimeSeconds / 60;
                  
                  if (waitTimeMins < 0 || waitTimeMins > MAX_WAIT_TIME_MINS) return; 

                  const trip2StopTimes = GTFS.stopTimesByTrip[trip2.trip_id];
                  if (!trip2StopTimes) return;

                  const st2_dest = trip2StopTimes.find(st => st.stop_id === destStop.stop_id);
                  
                  if (st2_dest && parseInt(st2_transfer.stop_sequence) < parseInt(st2_dest.stop_sequence)) {
                      // Found a 1-transfer route!
                      
                      const arrivalTimeDestSeconds = timeToSeconds(st2_dest.arrival_time);
                      
                      // Total time from NOW (current time) to arrival at final destination (including final walk)
                      const totalTime = (arrivalTimeDestSeconds - startTimeSeconds) / 60 + walkTimeDest;
                      
                      const bus1Time = (arrivalTimeTransferSeconds - trip1DepartureTimeSeconds) / 60;
                      const bus2Time = (arrivalTimeDestSeconds - departureTimeTransferSeconds) / 60;
                      
                      // Final Arrival Time (with walking)
                      const arrivalTimeFinalSeconds = arrivalTimeDestSeconds + (walkTimeDest * 60);
                      
                      allItineraries.push({
                          transfers: 1,
                          totalTime: totalTime, 
                          departureTime: secondsToTime(trip1DepartureTimeSeconds),
                          arrivalTime: secondsToTime(arrivalTimeFinalSeconds),
                          segments: [{
                              type: 'Walk to Origin', duration: formatMinutes(walkTimeOrigin), details: `üö∂ Caminhe at√© ${originStop.stop_name}`
                          }, {
                              type: 'Bus', route: route1, from: originStop, to: transferStop1, trip: trip1, 
                              departure: secondsToTime(trip1DepartureTimeSeconds), 
                              arrival: secondsToTime(arrivalTimeTransferSeconds), duration: formatMinutes(bus1Time)
                          }, {
                              type: 'Wait/Transfer', duration: formatMinutes(waitTimeMins), details: `‚è≥ Aguarde ${formatMinutes(waitTimeMins)} para o pr√≥ximo √¥nibus em ${transferStop1.stop_name}`, stop: transferStop1
                          }, {
                              type: 'Bus', route: route2, from: transferStop1, to: destStop, trip: trip2, 
                              departure: secondsToTime(departureTimeTransferSeconds), 
                              arrival: secondsToTime(arrivalTimeDestSeconds), duration: formatMinutes(bus2Time)
                          }, {
                              type: 'Walk to Destination', duration: formatMinutes(walkTimeDest), details: `üö∂ Caminhe de ${destStop.stop_name} ao destino final`
                          }]
                      });
                  }
              });
          });
      });

      // Sort by total travel time (fastest first)
      allItineraries.sort((a, b) => a.totalTime - b.totalTime);
      currentItineraries = allItineraries; // Save for map drawing
      
      return { closestOriginStop: closestOriginStop, closestDestStop: closestDestStop, itineraries: allItineraries };
  }

  // AJUSTE: Fun√ß√£o drawItinerary para cores e tra√ßados distintos (Planejador)
  function drawItinerary(index) {
      const itineraries = currentItineraries;
      if (index < 0 || index >= itineraries.length) return;
      
      const itinerary = itineraries[index];
      routeLayer.clearLayers(); 

      // Visualmente destacar a op√ß√£o selecionada na lista
      document.querySelectorAll('.route-option').forEach(el => {
          el.style.backgroundColor = '';
          el.style.boxShadow = '';
      });
      const selectedElement = document.querySelector(`.route-option[data-index="${index}"]`);
      if (selectedElement) {
          selectedElement.style.backgroundColor = 'var(--accent-2)';
          selectedElement.style.boxShadow = '0 0 10px rgba(0, 80, 41, 0.2)';
      }

      let bounds = [];
      let busSegmentCount = 0;

      // 1. Desenhar a p√© de A para o 1¬∫ Ponto de Partida
      const firstBusSegment = itinerary.segments.find(s => s.type === 'Bus');
      if (currentOriginStop && firstBusSegment) {
          const startCoord = getCoordsFromStop(currentOriginStop.stop);
          const endCoord = getCoordsFromStop(firstBusSegment.from);
          if (startCoord[0] !== endCoord[0] || startCoord[1] !== endCoord[1]) {
              const line = L.polyline([startCoord, endCoord], {
                  color: 'grey', 
                  weight: 4, 
                  opacity: 0.6, 
                  dashArray: '10, 10' 
              }).addTo(routeLayer);
              bounds.push(line.getBounds());
          }
      }

      // 2. Desenhar as rotas de √¥nibus
      itinerary.segments.forEach(segment => {
          if (segment.type === 'Bus') {
              busSegmentCount++; 
              const route = segment.route;
              const trip = segment.trip;
              
              let color = 'FF0000'; // Default: RED para rotas diretas
              let dashArray = null;

              if (itinerary.transfers > 0) {
                  // Cores distintas para baldea√ß√£o
                  color = (busSegmentCount === 1) ? '00AEEF' : '9900CC'; // Azul Claro / Roxo
              } else {
                  // Rota direta: usa a cor GTFS se houver, sen√£o vermelho padr√£o
                  color = route.route_color || 'FF0000'; 
              }

              const shape = GTFS.shapesById[trip.shape_id];
              if(!shape) return;

              // Desenhar o tra√ßado: MAIS GROSSO E OPACO
              const polyline = L.polyline(shape, {
                  color: `#${color.replace('#','')}`, 
                  weight: 8, 
                  opacity: 1.0, 
                  dashArray: dashArray 
              }).addTo(routeLayer);
              bounds.push(polyline.getBounds());
              
              // Marcar Paradas (Partida/Transfer/Chegada)
              const stopsToMark = [segment.from, segment.to];
              stopsToMark.forEach(stop => {
                  const isTransfer = itinerary.transfers === 1 && segment.type === 'Bus' && (stop.stop_id === segment.to.stop_id); 
                  
                  const marker = L.circleMarker(getCoordsFromStop(stop), {
                      radius: isTransfer ? 12 : 8, 
                      color: 'white',
                      fillColor: isTransfer ? '#FF8C00' : `#${color.replace('#','')}`, // Laranja Forte para Baldea√ß√£o
                      fillOpacity: 1,
                      weight: isTransfer ? 4 : 3
                  }).addTo(routeLayer)
                  .bindPopup(`<b>${stop.stop_name}</b><br>${isTransfer ? 'PONTO DE BALDEA√á√ÉO' : (stop === segment.from ? 'Partida' : 'Chegada')}`);
                  bounds.push(marker.getLatLng());
              });
          } else if (segment.type === 'Wait/Transfer' && itinerary.transfers > 0) {
              // Se for Baldea√ß√£o (Walk between bus 1 and bus 2) - Not necessary since the current logic assumes stop-to-stop transfer.
              // If the user needs to walk to a *different* stop for transfer, we would draw a line between segment.stop and segment.stop.
          }
      });
      
      // 3. Desenhar a p√© do √öltimo Ponto de Chegada para B (Destino)
      const lastBusSegment = itinerary.segments.filter(s => s.type === 'Bus').pop();
      if (currentDestStop && lastBusSegment) {
          const startCoord = getCoordsFromStop(lastBusSegment.to);
          const endCoord = getCoordsFromStop(currentDestStop.stop);
          if (startCoord[0] !== endCoord[0] || startCoord[1] !== endCoord[1]) {
              const line = L.polyline([startCoord, endCoord], {
                  color: 'grey', 
                  weight: 4, 
                  opacity: 0.6, 
                  dashArray: '10, 10' 
              }).addTo(routeLayer);
              bounds.push(line.getBounds());
          }
      }

      // 4. Desenhar marcadores A e B por √∫ltimo para garantir visibilidade
      if (currentOriginStop && currentDestStop) {
        L.marker(getCoordsFromStop(currentOriginStop.stop), { 
            icon: L.divIcon({className: 'geop-location-marker', html: 'A', style: 'color: #00A300; border-color: #00A300;'}) // VERDE
        }).addTo(routeLayer)
        .bindPopup(`<b>ORIGEM: ${currentOriginStop.stop.stop_name}</b>`);
        
        L.marker(getCoordsFromStop(currentDestStop.stop), { 
            icon: L.divIcon({className: 'geop-location-marker', html: 'B', style: 'color: red; border-color: red;'}) // VERMELHO
        }).addTo(routeLayer)
        .bindPopup(`<b>DESTINO: ${currentDestStop.stop.stop_name}</b>`);
      }


      // Ajustar o mapa para exibir todas as rotas e marcadores
      if (bounds.length > 0) {
          map.fitBounds(L.latLngBounds(bounds).pad(0.1));
      }
      
      // Atualizar Melhor Op√ß√£o
      const bestOption = $('bestOption');
      const routeSummary = itinerary.segments.filter(s => s.type === 'Bus').map(s => `üöå ${s.route.route_short_name}`).join(' ‚Üí ');
      
      bestOption.innerHTML = `
          <div style="font-size:18px; font-weight:700; color:var(--accent-3);">${secondsToTime(timeToSeconds(itinerary.departureTime))} ‚Üí ${secondsToTime(timeToSeconds(itinerary.arrivalTime))}</div>
          <div class="details" style="font-size:15px; font-weight:600; margin-top:4px;">Linhas: ${routeSummary} | Tempo Total: ${formatMinutes(itinerary.totalTime)}</div>
          <div class="details" style="margin-top:4px;">Tipo: ${itinerary.transfers === 0 ? 'Rota Direta (1 √înibus)' : 'Com 1 Baldea√ß√£o (2 √înibus) *Cores diferentes no Mapa'}</div>
          <button onclick="drawItinerary(${index})" style="margin-top:8px; width:100%">Recarregar Mapa/Itiner√°rio</button>
      `;
  }


  function renderItineraries(searchResult) {
      const { closestOriginStop, closestDestStop, itineraries } = searchResult;
      const routesBetween = $('routesBetween');
      const bestOption = $('bestOption');
      
      routeLayer.clearLayers(); 

      if (!closestOriginStop || !closestDestStop) {
          routesBetween.innerHTML = '<p style="color:#ff5c5c; font-weight:600;">N√£o foi poss√≠vel encontrar uma parada GTFS pr√≥xima √† origem ou destino com o texto informado.</p>';
          bestOption.innerHTML = 'Nenhuma rota encontrada.';
          return;
      }

      // Salva os stops globais para uso no drawItinerary
      // J√° feito dentro de findItineraries, mas repetido para clareza:
      currentOriginStop = closestOriginStop;
      currentDestStop = closestDestStop;
      
      const originStop = closestOriginStop.stop;
      const destStop = closestDestStop.stop;

      // Display Origin/Destination Info
      let infoHtml = `
          <div style="font-size:13px; color:var(--muted); margin-bottom:12px; padding:8px; background:#f8fafc; border-radius:8px;">
              **Parada de Embarque (Aprox.):** ${originStop.stop_name} (${closestOriginStop.distance.toFixed(0)}m a p√©)<br>
              **Parada de Desembarque (Aprox.):** ${destStop.stop_name} (${closestDestStop.distance.toFixed(0)}m a p√©)
          </div>
      `;
      routesBetween.innerHTML = infoHtml;

      // Define os limites do mapa para A e B antes de desenhar a rota
      map.fitBounds(L.latLngBounds([originStop.stop_lat, originStop.stop_lon], [destStop.stop_lat, destStop.stop_lon]).pad(0.3));
      
      if (itineraries.length === 0) {
          routesBetween.innerHTML += '<p>Nenhuma rota (direta ou com 1 baldea√ß√£o) encontrada a partir de agora. Tente um hor√°rio posterior.</p>';
          bestOption.innerHTML = 'Nenhuma rota encontrada.';
          return;
      }

      const best = itineraries[0];
      
      // Render Best Option Panel
      bestOption.innerHTML = `
          <div style="font-size:18px; font-weight:700; color:var(--accent-3);">${secondsToTime(timeToSeconds(best.departureTime))} ‚Üí ${secondsToTime(timeToSeconds(best.arrivalTime))}</div>
          <div class="details" style="font-size:15px; font-weight:600; margin-top:4px;">Tempo Total: ${formatMinutes(best.totalTime)}</div>
          <div class="details" style="margin-top:4px;">Tipo: ${best.transfers === 0 ? 'Rota Direta (1 √înibus)' : 'Com 1 Baldea√ß√£o (2 √înibus)'}</div>
          <button onclick="drawItinerary(0)" style="margin-top:8px; width:100%">Ver no Mapa</button>
      `;

      // Render List of Options
      routesBetween.innerHTML += itineraries.map((item, index) => {
          const routeSummary = item.segments.filter(s => s.type === 'Bus').map(s => `üöå ${s.route.route_short_name}`).join(' ');
          const firstBusSegment = item.segments.find(s => s.type === 'Bus');
          const color = firstBusSegment ? firstBusSegment.route.route_color || 'FF0000' : 'FF0000'; // Cor da Linha 1 para destaque
          const routeType = item.transfers === 0 ? 'Direta (1 √înibus)' : 'Baldea√ß√£o (2 √înibus)';
          
          return `
              <div class="route-option" onclick="drawItinerary(${index})" data-index="${index}" style="border-left: 4px solid #${color}; padding-left:10px;">
                  <strong style="color:#${color}">Linhas: ${routeSummary}</strong>
                  <div style="margin-top:4px; font-size:14px;">
                      <span style="font-weight:700; color:var(--accent);">${secondsToTime(timeToSeconds(item.departureTime))} ‚Üí ${secondsToTime(timeToSeconds(item.arrivalTime))}</span>
                      ‚Ä¢ ${formatMinutes(item.totalTime)} Total
                  </div>
                  <div class="details">${routeType}</div>
                  <div class="details" style="margin-top:8px;">
                      ${item.segments.map(s => {
                          let info = s.details;
                          if(s.type === 'Bus') info = `üöå Linha ${s.route.route_short_name} (${s.departure}) ‚Üí ${s.arrival}`;
                          
                          return `<div style="margin-left: -2px; font-size:12px;">${info} (${s.duration})</div>`;
                      }).join('')}
                  </div>
              </div>
          `;
      }).join('');
      
      // Draw the best route by default
      drawItinerary(0);
  }
  
  $('searchBtn').addEventListener('click', () => {
      const originName = $('originInput').value.trim();
      const destName = $('destInput').value.trim();
      const dateStr = $('planDateInput').value;

      if (!originName || !destName || !dateStr) {
          alert('Por favor, preencha a Origem, o Destino e a Data da Viagem.');
          return;
      }

      $('routesBetween').innerHTML = '<p style="padding:16px; text-align:center;">Buscando as melhores op√ß√µes...</p>';
      $('bestOption').innerHTML = 'Calculando...';
      routeLayer.clearLayers();
      
      const searchResult = findItineraries(originName, destName, dateStr);
      renderItineraries(searchResult);

      $('searchSummary').textContent = `Trajeto A‚ÜíB: ${searchResult.itineraries.length} rotas encontradas.`;
  });

  $('clearBtn').addEventListener('click', () => {
      clearAllTabs();
      routeLayer.clearLayers();
  });
  
  /************************************************************************
   * Fun√ß√µes de Data
   ************************************************************************/
  function determineDayType(dateStr) {
      const date = new Date(dateStr + 'T00:00:00'); 
      const day = date.getDay(); 
      let dayType = 'Dia √ötil';
      let dayIndex = day;
      
      if (day === 0) { 
          dayType = 'Domingo';
          dayIndex = 0;
      } else if (day === 6) { 
          dayType = 'S√°bado';
          dayIndex = 6;
      }
      return { type: dayType, dayIndex: dayIndex };
  }
  
  function updateDayTypeDisplay(){
      const scheduleDateInput = $('scheduleDateInput');
      const activeDayDisplay = $('activeDayDisplay');
      if(scheduleDateInput && activeDayDisplay && scheduleDateInput.value){
          const dayInfo = determineDayType(scheduleDateInput.value);
          activeDayDisplay.textContent = dayInfo.type;
      }
  }

  function setupDateListeners(){
      const today = new Date().toISOString().substring(0, 10);
      $('scheduleDateInput').value = today;
      $('scheduleDateInput').addEventListener('change', updateDayTypeDisplay);
      $('planDateInput').value = today;
      updateDayTypeDisplay();
  }
  
  /************************************************************************
   * INIT
   ************************************************************************/
  document.addEventListener('DOMContentLoaded', tryLoadGTFSFromRelative);
  $('loadBtn').addEventListener('click', tryLoadGTFSFromRelative);
  
  document.querySelectorAll('.tab-btn').forEach(button => {
    button.addEventListener('click', function() {
      const tab = this.dataset.tab;
      if(tab === 'tools' && sessionStorage.getItem('sim_role') !== 'admin'){
        openAuthModal('tools'); return;
      }
      activateTabButton(this);
    });
  });

  // Listener para o bot√£o de atalho da tab Plan para a tab Search
  $('goToScheduleBtn').addEventListener('click', () => {
      const searchTabButton = $('tabSearch');
      if (searchTabButton) {
          activateTabButton(searchTabButton);
      }
  });
  </script>
</body>
</html>